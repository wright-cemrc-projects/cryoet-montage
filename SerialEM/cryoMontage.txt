MacroName cryoMontage

Echo ============ cryoMontage ===============

# Author: Jae Yang <jyang525@wisc.edu>

# Developed in Elizabeth Wright Group at University of Wisconsin-Madison, WI, US

# Last modified: Dec. 20th 2021


### Adjust the parameters below together with Tomographer to specify your montage tilt series schemes


### basic settings ###
tilt_scheme = 0               # 0 = dose-symmetric, 1 = bidirectional
Debug = 0                     # set to 1 for verbose output for debugging
eucentricity_option = 2       # 1 = rough, 2 = fine, 3 = rough and fine
file_setting = 1              # recommend to set to 1 to define a local path below
tolerance = 0.5               # redo tracking if larger than a fraction (tolerance) of an image 
defocus = -5                  

If $Debug == 0
 SuppressReports
Endif

### file setting ###
If $file_setting == 1
 BaseDir = X:\RawData\wright\jyang525\2021_12_13\EOS\W1505_G2    # define a local path to save log files
 
 # DO NOT CHANGE BELOW
 ReportCurrentFileName 4   
 SetDirectory $BaseDir
 baselogname = $reportedValue4
 SaveLogOpenNew $baselogname
 Echo New log file open $baselogname
Endif
###

### Spiral translation settings ###
Ainitial = 0
Afinal = 1.5         # default as 1.5 with a maximum offset of 0.8 micron 
turns = 50           # larger number, bigger shift offsets
period = 3           # generally change the spiral turning sharpness
revolution = 15      # generally no need to change

Echo Spiral parameters: Ainitial = $Ainitial  Afinal = $Afinal  turns = $turns  period = $period  revolution = $revolution
###


### Dose-symmetric settings ###
startAngleDS = 0    # starting angle, set to nonzero for lamella
endAngleDS = 60     # positive end angle, if set to 60 for a tilt range of -60 to 60
stepSizeDS = 3      # tilt increment
groupSizeDS = 3     # number of tilts per group                           
trackingShot = T    # use Trial for tracking, can also be set to V to use View shot
doExtraTrackingShot = 0  # 1 to do extra tracking with Trial in focus area
###

### Bi-directional settings ###
startAngleBi = 0     # starting angle of the first half, set to nonzero for asymmetric collection
firstSideEnd = 60    # end angle of the first half
secondSideStart = -3 # starting angle of the second half
secondSideEnd = -60  # end angle of the second half
stepSizeBi = 3       # tilt increment
###




### We recommend not to change the Main Script section below for regular applications


### Main script starts ###

TiltTo 0
                 
# Align to TOI and restore TOI image shift
Eucentricity $eucentricity_option 
UpdateItemZ
RealignToNavItem 1 0 0.1 4 0
Copy A S
ResetImageShift
View
AlignTo S  
ReportImageShift
isux = $repVal1
isuy = $repVal2

# generate extra tracking shot
If $doExtraTrackingShot == 1 
Trial
Copy A W
Endif

If $Debug == 1
Echo image shift after realignTo item: $repVal1 $repVal2
Endif

ResetClock
SuppressReports

### Start the tilt series collection ###
If $tilt_scheme == 0
 CallFunction TS_dose_symmetric $startAngleDS $endAngleDS $stepSizeDS $groupSizeDS
ElseIf $tilt_scheme == 1
 CallFunction TS_bidirectional $startAngleBi $firstSideEnd $secondSideStart $secondSideEnd $stepSizeBi
Endif

TiltTo 0
ReportClock ts_time
Echo TS time: $ts_time

### main script end ###


### We recommend not to change the Function section below for regular applications


##############################

Function TS_dose_symmetric 4 0

Echo ====== starting dose symmetric TS =======
startAngle = $argVal1
endAngle = $argVal2
stepSize = $argVal3
groupSize = $argVal4
direction = -1 # DO NOT CHANGE

# buffers to store tracking images

rightTrackingBuf = P # DO NOT CHANGE
leftTrackingBuf = Q # DO NOT CHANGE
rightTrackingTrial = U # DO NOT CHANGE
leftTrackingTrial = V  # DO NOT CHANGE

# check tilt group switch and prevent over tilting

multiStepTilt_StepSize = 25 # DO NOT CHANGE

# generate list of angles and translation
  
transX = { $startAngle }
transY = { $startAngle }
angles = { $startAngle }
numberTilts = ( $endAngle - $startAngle ) / $stepSize
Echo numberTilts $numberTilts
numberTilts = $numberTilts + 1
Echo numberTilts $numberTilts
revolution_2 = $revolution * 3.14
cycles = $revolution_2 * $turns
bgrowth = ( $Ainitial - $Afinal ) / $cycles 
bgrowth = $bgrowth * $direction

If $Debug == 1     
 Echo translation revolution = $bgrowth  cycles = $cycles
Endif

If $doExtraTrackingShot == 1 
 Echo extra tracking with Trial is on
Endif

Loop 99 i
  # generate list of translation
  i_minus_one = $i - 1
  gsMinusOne = $groupSize - 1
  d_alpha = $i_minus_one * $gsMinusOne
  If $Debug == 1  
     Echo d_alpha   $d_alpha
  Endif
  IS_Angle = ( $i + $d_alpha ) * 360 * $period / $numberTilts
  IS_Rad = ( $bgrowth * $IS_Angle ) + $Ainitial
  IS_sin = SIN ( $IS_Angle) 
  IS_cos = COS ( $IS_Angle)
  PosiX = $IS_cos * $IS_Rad
  NegX = $IS_cos * $IS_Rad * $direction
  PosiY = $IS_sin * $IS_Rad
  NegY = $IS_sin * $IS_Rad * $direction

  If $Debug == 1
     Echo IS_Angle = $IS_Angle  IS_Rad = $IS_Rad IS_sin = $IS_sin IS_cos = $IS_cos period = $period
     Echo PosiX = $PosiX  NegX = $NegX  PosiY = $PosiY  NegY = $NegY
  Endif 
        
  If $i > $numberTilts
     break
  Endif
  PosiXs = { $PosiX }
  NegXs = { $NegX }
  PosiYs = { $PosiY }
  NegYs = { $NegY }

  If $Debug == 1    
     Echo PosiXs = $PosiXs NegXs = $NegXs PosiYx = $PosiYs  NegYs = $NegYs
  Endif
      
    Loop $gsMinusOne j
       nextIS_Angle = ( $i + $d_alpha + $j ) * 360 * 3 / $numberTilts
       nextIS_Rad = $bgrowth * $nextIS_Angle + $Ainitial
       nextIS_sin = SIN ( $nextIS_Angle) 
       nextIS_cos = COS ( $nextIS_Angle)
       nextPosiX = $nextIS_cos * $nextIS_Rad
       nextNegX = $nextIS_cos * $nextIS_Rad * $direction
       nextPosiY = $nextIS_sin * $nextIS_Rad
       nextNegY = $nextIS_sin * $nextIS_Rad * $direction
       PosiXs = { $PosiXs $nextPosiX }
       NegXs = { $NegXs $nextNegX }
       PosiYs = { $PosiYs $nextPosiY }
       NegYs = { $NegYs $nextNegY }
       If $Debug == 1
         Echo nextIS_Angle = $nextIS_Angle   nextIS_Rad = $nextIS_Rad   nextIS_sin = $nextIS_sin   nextIS_cos = $nextIS_cos
         Echo PosiXs = $PosiXs  NegXs = $NegXs  PosiYs = $PosiYs  NegYs = $NegYs
       Endif
    EndLoop
    i_is_odd = MODULO $i 2
    If $i_is_odd == 1
       transX = { $transX $PosiXs }
       transX = { $transX $NegXs }
       transY = { $transY $PosiYs }
       transY = { $transY $NegYs }
     Else
       transX = { $transX $NegXs }
       transX = { $transX $PosiXs }
       transY = { $transY $NegYs }
       transY = { $transY $PosiYs }
     Endif
     If $Debug == 1
       Echo translation X  $transX per tilt 
       Echo translation Y  $transY per tilt  
     Endif

  #generate a list of angle
  i_minus_one = $i - 1
  d_theta = $stepSize + $i_minus_one * $stepSize * $groupSize
  angleR = $startAngle + $d_theta
  angleL = $startAngle - $d_theta

  If $Debug == 1
    Echo d_theta = $d_theta angleR = $angleR angleL = $angleL
  Endif 

  If $angleR > $endAngle OR $angleL < -1 * $endAngle
    break
  Endif
  rightSide = { $angleR }
  leftSide = { $angleL }
  
  If $Debug == 1
      Echo rightSide = $rightSide leftSide = $leftSide
  Endif

  gsMinusOne = $groupSize - 1
    Loop $gsMinusOne j
       nextAngleR = $angleR + $j * $stepSize
       nextAngleL = $angleL - $j * $stepSize
       If $nextAngleR > $endAngle OR $nextAngleL < -1 * $endAngle
           break
       Endif
       rightSide = { $rightSide $nextAngleR }
       leftSide = { $leftSide $nextAngleL }
     If $Debug == 1
      Echo rightSide = $rightSide   LeftSide = $leftSide
     Endif
    EndLoop
    i_is_odd = MODULO $i 2
    If $i_is_odd == 1
       angles = { $angles $rightSide }
       angles = { $angles $leftSide }
    Else
       angles = { $angles $leftSide }
       angles = { $angles $rightSide }
    Endif
EndLoop

If $Debug == 1
 Echo Angles $angles
Endif

Loop $#angles i
   a = $angles[$#angles-$i+1] - $startAngle
   b = $angles[$#angles-$i] - $startAngle
   If $a * $b < 0
      angleLastTrackingShot = $angles[$#angles-$i]
      Echo angleLastTrackingShot = $angleLastTrackingShot
      break
      Endif
EndLoop

firstRightGroupDone = 0
firstLeftGroupDone = 0

# tilt collection starts  
Loop $#angles i
  angle = $angles[$i]
  Echo angle = $angle  

  If $Debug == 0
    Echo transX = $transX[$i]  transY = $transY[$i]
  Endif

  TiltTo $angle
  Echo Tilt angle = $angle
  Delay 5

  If $i == 1 AND $startAngle == 0
     GoToLowDoseArea V
     ResetShiftIfAbove 2
     AlignTo S
     View
     Copy A $rightTrackingBuf
     Copy A $leftTrackingBuf
     ReportImageShift
     isux = $repVal1
     isuy = $repVal2

     If $doExtraTrackingShot == 1 
        Trial
        AlignTo W
        Copy A $rightTrackingTrial
        Copy A $leftTrackingTrial
     Endif

     If $Debug == 1
      Echo isux = $isux  isuy = $isuy
     Endif                  
  Endif

  # if coming from opposite side, align to tracking shot
  If $i > 1     
    If $angles[$i] > $startAngle AND $angles[$i-1] < $startAngle AND $firstRightGroupDone == 1
       Echo Aligning to positive side tracking shot
       $trackingShot

       ImageProperties
       imgWidth = $repVal1
       imgHeight = $repVal2
       minSide = MIN $imgWidth $imgHeight
       imgBinning = $repVal3

       AlignTo $rightTrackingBuf
       ReportAlignShift
       errX = $repVal1 / $imgBinning
       errY = $repVal2 / $imgBinning
       errorAlignV = $errX * $errX + $errY * $errY
       errorAlignV = SQRT $errorAlignV
       errorTol = $minSide * $tolerance
       Echo error in align in pixel = $errorAlignV   racking error tolerance in pixel = $errorTol 
       
      # reiterate tracking 
       If $errorAlignV > $errorTol
         Echo tracking error above tolerance errorTol = $errorTol    tracking error = $errorAlignV
         Echo redo tracking
         Loop 5
             $trackingShot
             AlignTo $rightTrackingBuf
             ReportAlignShift
             errX = $repVal1 / $imgBinning
             errY = $repVal2 / $imgBinning
             errorAlignV = $errX * $errX + $errY * $errY
             errorAlignV = SQRT $errorAlignV

             If $Debug == 1
                Echo error in align = $errorAlignV
             Endif

             If $errorAlignV < $errorTol
                 Echo error in tracking is $errorAlignV within tolerance $errorTol
                 break
             Endif
          EndLoop
          If $errorAlignV > $errorTol
              Echo error in tracking is $errorAlignV out of tolerance $errorTol after 5 iterations
              StopContinuous
          Endif
        Endif
          
       ReportImageShift
       isux = $repVal1
       isuy = $repVal2
       If $Debug == 1
           Echo isux = $isux  isuy = $isuy
       Endif
     ElseIf $angles[$i] < $startAngle AND $angles[$i-1] > $startAngle AND $firstLeftGroupDone == 1
       Echo Aligning to negative side tracking shot
       $trackingShot

       ImageProperties
       imgWidth = $repVal1
       imgHeight = $repVal2
       minSide = MIN $imgWidth $imgHeight
       imgBinning = $repVal3

       AlignTo $leftTrackingBuf
       ReportAlignShift
       errX = $repVal1 / $imgBinning
       errY = $repVal2 / $imgBinning
       errorAlignV = $errX * $errX + $errY * $errY
       errorAlignV = SQRT $errorAlignV
       errorTol = $minSide * $tolerance
       Echo error in align in pixel = $errorAlignV   racking error tolerance in pixel = $errorTol 
 
    # reiterate tracking 
       If $errorAlignV > $errorTol
         Echo tracking error above tolerance errorTol = $errorTol   tracking error = $errorAlignV
         Echo redo tracking
         Loop 5
             $trackingShot
             AlignTo $leftTrackingBuf
             ReportAlignShift
             errX = $repVal1 / $imgBinning
             errY = $repVal2 / $imgBinning
             errorAlignV = $errX * $errX + $errY * $errY
             errorAlignV = SQRT $errorAlignV

             If $Debug == 1
                Echo error in align = $errorAlignV
             Endif

             If $errorAlignV < $errorTol
                   Echo error in tracking is $errorAlignV within tolerance $errorTol
                   break
              Endif
          EndLoop
          
          If $errorAlignV > $errorTol
              Echo error in tracking is $errorAlignV out of tolerance $errorTol after 5 iterations
              StopContinuous
          Endif
        Endif
       
       ReportImageShift
       isux = $repVal1
       isuy = $repVal2
       If $Debug == 1
           Echo isux = $isux  isuy = $isuy
       Endif
     Endif

 # extra tracking when on 
  If $startAngle == 0 AND $doExtraTrackingShot == 1
    $trackingShot
     If $angles[$i] < $startAngle
       AlignTo $leftTrackingTrial
       ReportImageShift
       isux = $repVal1
       isuy = $repVal2
       If $Debug == 1
        Echo isux = $isux  isuy = $isuy
       Endif
     ElseIf $angles[$i] > $startAngle
       AlignTo $rightTrackingTrial
       ReportImageShift
       isux = $repVal1
       isuy = $repVal2
       If $Debug == 1
        Echo isux = $isux  isuy = $isuy
       Endif
     Endif
  Endif
 Endif

 GoToLowDoseArea R
 SetTargetDefocus $defocus
 Echo set target defocus = $defocus
 # set spiral image shift 
 shiftX = $transX[$i] + $isux
 shiftY = $transY[$i] + $isuy
 ImageShiftByMicrons $shiftX $shiftY
 Echo Image shift by microns: shiftX = $shiftX  shiftY = $shiftY 
 
 If $Debug == 1
  Echo transX = $transX[$i]  transY = $transY[$i]
 Endif

 CallFunction WaitingToFill
 Autofocus
 MultipleRecords
 Save
 ReportImageShift
 Echo current image shift: $repVal1 $repVal2
 SetImageShift $isux $isuy
 Echo reset image shift to: $isux $isuy
 ReportImageShift
 Echo current image shift after reset: $repVal1 $repVal2
      
 If $i > 1 AND $i < $#angles AND $angles[$i] != $angleLastTrackingShot
    If $angles[$i] > $startAngle AND $angles[$i+1] < $startAngle
       Echo Next tilt will switch to negative left side, saving a tracking shot
       $trackingShot
       Copy A $rightTrackingBuf
       firstRightGroupDone = 1
    ElseIf $angles[$i] < $startAngle AND $angles[$i+1] > $startAngle
       Echo Next tilt will switch to positive right side, saving a tracking shot
       $trackingShot
       Copy A $leftTrackingBuf
       firstLeftGroupDone = 1
    Endif
 Endif

EndLoop

TiltTo 0
Delay 5
Echo   ============== end of dose symmetric TS =====================

EndFunction

#########################################################

Function TiltToMultiStep 1 0
     toAngle = $argVal1
     ReportTiltAngle
     Echo TiltAngle  $repVal1
     fromAngle = $repVal1

    If $toAngle > $fromAngle
       Direction = 1
    Else
      Ddirection = -1
    Endif

    change = ABS $toAngle - $fromAngle
    Echo change $change
    Loop 99 
         If $change > $multiStepTilt_StepSize
            TiltBy $Direction * $multiStepTilt_StepSize
             change = $change - $multiStepTilt_StepSize
         Else
             TiltTo $toAngle
             break
         Endif
     EndLoop

EndFunction

#######################

Function TS_bidirectional 5 0

Echo ====== starting bidirectional TS =========
   startAngle = $argVal1
   endAngleFirstSide = $argVal2
   secondSideStart = $argVal3
   endAngleSecondSide = $argVal4
   stepSize = $argVal5
   
   CallFunction WaitingToFill

# first side
Echo ======== starting the first half ============
If $Debug == 1
 Echo Anitial = $Ainitial       Afinal = $Afinal       turns = $turns
Endif
WalkUpTo $startAngle
ResetShiftIfAbove 2

# override S with tilted starting View
View
Copy A S
ReportImageShift
isux = $repVal1
isuy = $repVal2

CallFunction TS_unidirectional $startAngle $endAngleFirstSide $stepSize 

# second side
# backlash removal
If $endAngleSecondSide > $startAngle
   direction = 1
ElseIf $endAngleSecondSide < $startAngle
   direction = -1
Endif
angleCorrectBacklash = $startAngle - 3 * $direction
TiltTo $angleCorrectBacklash
TiltTo $secondSideStart
# get residual IS between current location and map image
View
AlignTo S
ResetShiftIfAbove 2
ReportImageShift
isux = $repVal1
isux = $repVal2

Echo ====== starting the second half ========
   CallFunction TS_unidirectional $secondSideStart $endAngleSecondSide $stepSize 
Echo ====== end of bidirectional TS ========

EndFunction

#######################

Function TS_unidirectional 3 0

Echo ===== starting unidirectional TS ======
startAngle = $argVal1
endAngle = $argVal2
stepSize = $argVal3

# define a direction variable for convenience
If $endAngle > $startAngle
  direction = 1
ElseIf $endAngle < $startAngle
  direction = -1
Else
   Echo Cannot set start and end angles to same value
   Exit
Endif

If $direction == 1
  numberTilts = ( $direction * $endAngle - $direction * $startAngle ) / $stepSize
  Echo numberTilts: $numberTilts   
  numberTilts = $numberTilts + 1
  Echo numberTilts: $numberTilts
ElseIf $direction == -1
  numberTilts = ( $direction * $endAngle - $direction * $startAngle ) / $stepSize
  Echo numberTilts: $numberTilts   
  numberTilts = $numberTilts + 2
  Echo numberTilts: $numberTilts
Endif

# create array of tilt angles
angles = { $startAngle }
Loop 99 i
  angle = $startAngle + $direction * $stepSize * $i
    If ($endAngle > $startAngle AND $angle > $endAngle) OR ($endAngle < $startAngle AND $angle < $endAngle)
     break
    Endif
   angles = { $angles $angle }
EndLoop
   

# start tilt series
Loop $#angles i
   angle = $angles[$i]
   Echo tilt angle: $angle
     
   GoToLowDoseArea R
   SetTargetDefocus $defocus

   TiltTo $angle
   Delay 5

 # set the translation

   If $direction == 1
     IS_Angle = ( $i - 1 ) * 360 * $period / $numberTilts
   ElseIf $direction == -1
     IS_Angle = $i * 360 * $period / $numberTilts
   Endif
  revolution_2 = $revolution * 3.14
  cycles = $revolution_2 * $turns
  bgrowth = ($Afinal - $Ainitial ) / $cycles
  IS_Rad = ( $bgrowth * $IS_Angle )
  IS_Rad = $Ainitial + $IS_Rad
  IS_sin = SIN ( $IS_Angle ) 
  IS_cos = COS ( $IS_Angle )
  IS_x = $IS_cos * $IS_Rad
  IS_y = $IS_Rad * $IS_sin
  TransR_X = $direction * $IS_x
  TransR_Y = $direction * $IS_y
  shiftX = $isux +$TransR_X
  shiftY = $isuy + $TransR_Y
  ImageShiftByMicrons $shiftX $shiftY

   If $Debug == 1
    Echo revolution = $revolution   cycles = $cycles    
    Echo IS_Angle = $IS_Angle  bgrowth = $bgrowth  
    Echo IS_Rad = $IS_Rad
    Echo IS_Rad = $IS_Rad        
    Echo IS_sin = $IS_sin   IS_cos = $IS_cos   IS_x = $IS_x    IS_y = $IS_y    
    Echo TransR_X = $TransR_X  TransR_Y = $TransR_Y  ImageShiftBy Microns $shiftX $shiftY
   Endif

   CallFunction WaitingToFill
   MultipleRecords
   Save
   ReportImageShift
   Echo current image shift: $repVal1 $repVal2
   SetImageShift $isux $isuy
   Echo reset image shift to: $isux $isuy
   ReportImageShift
   Echo current image shift after reset: $repVal1 $repVal2
EndLoop

TiltTo 0
EndFunction 

#######################
Function WaitingToFill
Delay 2
Loop 15
           AreDewarsFilling
          If $reportedValue1 == 0
                              echo dewars are not filling
                              break
          ElseIf $reportedValue1 == 1
                              echo dewars are filling
                              delay 60 sec
          Endif
      EndLoop
EndFunction
