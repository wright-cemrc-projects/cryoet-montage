MacroName cryoMontage

Echo ============ cryoMontage ===============
*
* Author: Jae Yang <jyang525@wisc.edu>
* Developed by Elizabeth Wright Group at University of Wisconsin-Madison
* Last modified: Nov. 12, 2021
*

tilt_scheme = 0
# 0 = dose-symmetric
# 1 = bidirectional
Debug = 0  # set to 1 for verbose output for debugging
eucentricity_option = 2  # 1 = rough, 2 = fine, 3 = rough and fine
file_setting = 0 # set to 1 for file directory and output setting

If $Debug == 0
 SuppressReports
Endif

### File setting ###
If $file_setting == 1
 BaseDir = X:\RawData\wright\jyang525\2021_11_8\7\     # Edit for file saving location
 ReportCurrentFileName 4   # DO NOT CHANGE
 SetDirectory $BaseDir
 baselogname = $reportedValue4
 SaveLogOpenNew $baselogname
 Echo New log file open $baselogname
Endif
###

### dose-symmetric settings ###
startAngleDS = 0
endAngleDS = 51
stepSizeDS = 3
groupSizeDS = 3     # number of tilts before switching sides                            
trackingShot = T    # can also be set to V
defocus = -5
multiStepTilt_StepSize = 25
doExtraTrackingShot = 0
rightTrackingBuf = P
leftTrackingBuf = Q
###

### bi-directional settings ###
startAngleBi = 0
firstSideEnd = 51
secondSideStart = -3  
secondSideEnd = -51
stepSizeBi = 3
###

### Spiral translation settings ###
Ainitial = 0
Afinal = 1.3
turns = 50
period = 3
###

### main script starts ###

TiltTo 0
                 
# Align to TOI and restore TOI image shift
Eucentricity $eucentricity_option 
UpdateItemZ
RealignToNavItem 1 0 0.1 5 0
Copy A S
ResetImageShift
View
AlignTo S  
ReportImageShift
isux = $repVal1
isuy = $repVal2

If $Debug == 1
Echo image shift after realignTo item: $repVal1 $repVal2
Endif

ResetClock
SuppressReports

### Start the tilt series collection ###
If $tilt_scheme == 0
 CallFunction TS_dose_symmetric $startAngleDS $endAngleDS $stepSizeDS $groupSizeDS
ElseIf $tilt_scheme == 1
 CallFunction TS_bidirectional $startAngleBi $firstSideEnd $secondSideStart $secondSideEnd $stepSizeBi
Endif

TiltTo 0
ReportClock ts_time
Echo TS time: $ts_time

### main script end ###





##############################

Function TS_dose_symmetric 4 0

Echo ====== starting dose symmetric TS =======
startAngle = $argVal1
endAngle = $argVal2
stepSize = $argVal3
groupSize = $argVal4
direction = -1 # DO NOT CHANGE

# generate list of angles and translation
  
transX = { $startAngle }
transY = { $startAngle }
angles = { $startAngle }
numberTilts = ( $endAngle - $startAngle ) / $stepSize
Echo numberTilts $numberTilts
numberTilts = $numberTilts + 1
Echo numberTilts $numberTilts
cycles = 47 * $turns
bgrowth = ( $Ainitial - $Afinal ) / $cycles 
bgrowth = $bgrowth * $direction

If $Debug == 1     
 Echo translation revolution = $bgrowth  cycles = $cycles
Endif

Loop 99 i
  # generate list of translation
  i_minus_one = $i - 1
  gsMinusOne = $groupSize - 1
  d_alpha = $i_minus_one * $gsMinusOne
  If $Debug == 1  
     Echo d_alpha   $d_alpha
  Endif
  IS_Angle = ( $i + $d_alpha ) * 360 * $period / $numberTilts
  IS_Rad = ( $bgrowth * $IS_Angle ) + $Ainitial
  IS_sin = SIN ( $IS_Angle) 
  IS_cos = COS ( $IS_Angle)
  PosiX = $IS_cos * $IS_Rad
  NegX = $IS_cos * $IS_Rad * $direction
  PosiY = $IS_sin * $IS_Rad
  NegY = $IS_sin * $IS_Rad * $direction

  If $Debug == 1
     Echo IS_Angle = $IS_Angle  IS_Rad = $IS_Rad IS_sin = $IS_sin IS_cos = $IS_cos period = $period
     Echo PosiX = $PosiX  NegX = $NegX  PosiY = $PosiY  NegY = $NegY
  Endif 
        
  If $i > $numberTilts
     break
  Endif
  PosiXs = { $PosiX }
  NegXs = { $NegX }
  PosiYs = { $PosiY }
  NegYs = { $NegY }

  If $Debug == 1    
     Echo PosiXs = $PosiXs NegXs = $NegXs PosiYx = $PosiYs  NegYs = $NegYs
  Endif
      
    Loop $gsMinusOne j
       nextIS_Angle = ( $i + $d_alpha + $j ) * 360 * 3 / $numberTilts
       nextIS_Rad = $bgrowth * $nextIS_Angle + $Ainitial
       nextIS_sin = SIN ( $nextIS_Angle) 
       nextIS_cos = COS ( $nextIS_Angle)
       nextPosiX = $nextIS_cos * $nextIS_Rad
       nextNegX = $nextIS_cos * $nextIS_Rad * $direction
       nextPosiY = $nextIS_sin * $nextIS_Rad
       nextNegY = $nextIS_sin * $nextIS_Rad * $direction
       PosiXs = { $PosiXs $nextPosiX }
       NegXs = { $NegXs $nextNegX }
       PosiYs = { $PosiYs $nextPosiY }
       NegYs = { $NegYs $nextNegY }
       If $Debug == 1
         Echo nextIS_Angle = $nextIS_Angle   nextIS_Rad = $nextIS_Rad   nextIS_sin = $nextIS_sin   nextIS_cos = $nextIS_cos
         Echo PosiXs = $PosiXs  NegXs = $NegXs  PosiYs = $PosiYs  NegYs = $NegYs
       Endif
    EndLoop
    i_is_odd = MODULO $i 2
    If $i_is_odd == 1
       transX = { $transX $PosiXs }
       transX = { $transX $NegXs }
       transY = { $transY $PosiYs }
       transY = { $transY $NegYs }
     Else
       transX = { $transX $NegXs }
       transX = { $transX $PosiXs }
       transY = { $transY $NegYs }
       transY = { $transY $PosiYs }
     Endif
     If $Debug == 1
       Echo Dose symmetric translation X  $transX  
       Echo Dose symmetric translation Y  $transY    
     Endif

  #generate a list of angle
  i_minus_one = $i - 1
  d_theta = $stepSize + $i_minus_one * $stepSize * $groupSize
  angleR = $startAngle + $d_theta
  angleL = $startAngle - $d_theta

  If $Debug == 1
    Echo d_theta = $d_theta angleR = $angleR angleL = $angleL
  Endif 

  If $angleR > $endAngle OR $angleL < -1 * $endAngle
    break
  Endif
  rightSide = { $angleR }
  leftSide = { $angleL }
  
  If $Debug == 1
      Echo rightSide = $rightSide leftSide = $leftSide
  Endif

  gsMinusOne = $groupSize - 1
    Loop $gsMinusOne j
       nextAngleR = $angleR + $j * $stepSize
       nextAngleL = $angleL - $j * $stepSize
       If $nextAngleR > $endAngle OR $nextAngleL < -1 * $endAngle
           break
       Endif
       rightSide = { $rightSide $nextAngleR }
       leftSide = { $leftSide $nextAngleL }
     If $Debug == 1
      Echo rightSide = $rightSide   LeftSide = $leftSide
     Endif
    EndLoop
    i_is_odd = MODULO $i 2
    If $i_is_odd == 1
       angles = { $angles $rightSide }
       angles = { $angles $leftSide }
    Else
       angles = { $angles $leftSide }
       angles = { $angles $rightSide }
    Endif
EndLoop

If $Debug == 1
 Echo Angles $angles
Endif

Loop $#angles i
   a = $angles[$#angles-$i+1] - $startAngle
   b = $angles[$#angles-$i] - $startAngle
   If $a * $b < 0
      angleLastTrackingShot = $angles[$#angles-$i]
      Echo angleLastTrackingShot = $angleLastTrackingShot
      break
      Endif
EndLoop

firstRightGroupDone = 0
firstLeftGroupDone = 0
  
Loop $#angles i
  angle = $angles[$i]
  Echo angle = $angle  transX = $transX[$i]  transY = $transY[$i]

  TiltTo $angle
  Echo Tilt angle = $angle
  Delay 5

  If $i == 1 AND $startAngle == 0
     GoToLowDoseArea V
     ResetShiftIfAbove 2
     AlignTo S
     View
     Copy A $rightTrackingBuf
     Copy A $leftTrackingBuf
     ReportImageShift
     isux = $repVal1
     isuy = $repVal2
     If $Debug == 1
      Echo isux = $isux  isuy = $isuy
     Endif                  
  Endif

  # if coming from opposite side, align to tracking shot
  If $i > 1     
    If $angles[$i] > $startAngle AND $angles[$i-1] < $startAngle AND $firstRightGroupDone == 1
       Echo Aligning to positive side tracking shot
       $trackingShot
       AlignTo $rightTrackingBuf
       ReportImageShift
       isux = $repVal1
       isuy = $repVal2
       If $Debug == 1
           Echo isux = $isux  isuy = $isuy
       Endif
     ElseIf $angles[$i] < $startAngle AND $angles[$i-1] > $startAngle AND $firstLeftGroupDone == 1
       Echo Aligning to negative side tracking shot
       $trackingShot
       AlignTo $leftTrackingBuf
       ReportImageShift
       isux = $repVal1
       isuy = $repVal2
       If $Debug == 1
           Echo isux = $isux  isuy = $isuy
       Endif
     Endif

### extra tracking when on ##########
  If $startAngle == 0 AND $doExtraTrackingShot == 1
    $trackingShot
     If $angles[$i] < $startAngle
       AlignTo $leftTrackingBuf
       ReportImageShift
       isux = $repVal1
       isuy = $repVal2
       If $Debug == 1
        Echo isux = $isux  isuy = $isuy
       Endif
     ElseIf $angles[$i] > $startAngle
       AlignTo $rightTrackingBuf
       ReportImageShift
       isux = $repVal1
       isuy = $repVal2
       If $Debug == 1
        Echo isux = $isux  isuy = $isuy
       Endif
     Endif
  Endif
 Endif

 GoToLowDoseArea R
 SetTargetDefocus $defocus
 Echo set target defocus = $defocus
 # set spiral image shift 
 shiftX = $transX[$i] + $isux
 shiftY = $transY[$i] + $isuy
 ImageShiftByMicrons $shiftX $shiftY
 Echo Image shift by microns: shiftX = $shiftX  shiftY = $shiftY  
 If $Debug == 1
  transX = $transX[$i]  transY = $transY[$i]
 Endif

 CallFunction WaitingToFill
 Autofocus
 MultipleRecords
 Save
 ReportImageShift
 Echo current image shift: $repVal1 $repVal2
 SetImageShift $isux $isuy
 Echo reset image shift to: $isux $isuy
 ReportImageShift
 Echo current image shift after reset: $repVal1 $repVal2
      
 If $i > 1 AND $i < $#angles AND $angles[$i] != $angleLastTrackingShot
    If $angles[$i] > $startAngle AND $angles[$i+1] < $startAngle
       Echo Next tilt will switch to negative left side, saving a tracking shot
       $trackingShot
       Copy A $rightTrackingBuf
       firstRightGroupDone = 1
    ElseIf $angles[$i] < $startAngle AND $angles[$i+1] > $startAngle
       Echo Next tilt will switch to positive right side, saving a tracking shot
       $trackingShot
       Copy A $leftTrackingBuf
       firstLeftGroupDone = 1
    Endif
 Endif

EndLoop

TiltTo 0
Delay 5
Echo   ============== end of dose symmetric TS =====================

EndFunction

#########################################################

Function TiltToMultiStep 1 0
     toAngle = $argVal1
     ReportTiltAngle
     Echo TiltAngle  $repVal1
     fromAngle = $repVal1

    If $toAngle > $fromAngle
       Direction = 1
    Else
      Ddirection = -1
    Endif

    change = ABS $toAngle - $fromAngle
    Echo change $change
    Loop 99 
         If $change > $multiStepTilt_StepSize
            TiltBy $Direction * $multiStepTilt_StepSize
             change = $change - $multiStepTilt_StepSize
         Else
             TiltTo $toAngle
             break
         Endif
     EndLoop

EndFunction

#######################

Function TS_bidirectional 5 0

Echo ====== starting bidirectional TS =========
   startAngle = $argVal1
   endAngleFirstSide = $argVal2
   secondSideStart = $argVal3
   endAngleSecondSide = $argVal4
   stepSize = $argVal5
   
   CallFunction WaitingToFill

# first side
Echo ======== starting the first half ============
If $Debug == 1
 Echo Anitial = $Ainitial       Afinal = $Afinal       turns = $turns
Endif
WalkUpTo $startAngle
ResetShiftIfAbove 2

# override S with tilted starting View
View
Copy A S
ReportImageShift
isux = $repVal1
isuy = $repVal2

CallFunction TS_unidirectional $startAngle $endAngleFirstSide $stepSize 

# second side
# backlash removal
If $endAngleSecondSide > $startAngle
   direction = 1
ElseIf $endAngleSecondSide < $startAngle
   direction = -1
Endif
angleCorrectBacklash = $startAngle - 3 * $direction
TiltTo $angleCorrectBacklash
TiltTo $secondSideStart
# get residual IS between current location and map image
View
AlignTo S
ResetShiftIfAbove 2
ReportImageShift
isux = $repVal1
isux = $repVal2

Echo ====== starting the second half ========
   CallFunction TS_unidirectional $secondSideStart $endAngleSecondSide $stepSize 
Echo ====== end of bidirectional TS ========

EndFunction

#######################

Function TS_unidirectional 3 0

Echo ===== starting unidirectional TS ======
startAngle = $argVal1
endAngle = $argVal2
stepSize = $argVal3

# define a direction variable for convenience
If $endAngle > $startAngle
  direction = 1
ElseIf $endAngle < $startAngle
  direction = -1
Else
   Echo Cannot set start and end angles to same value
   Exit
Endif

If $direction == 1
  numberTilts = ( $direction * $endAngle - $direction * $startAngle ) / $stepSize
  Echo numberTilts: $numberTilts   
  numberTilts = $numberTilts + 1
  Echo numberTilts: $numberTilts
ElseIf $direction == -1
  numberTilts = ( $direction * $endAngle - $direction * $startAngle ) / $stepSize
  Echo numberTilts: $numberTilts   
  numberTilts = $numberTilts + 2
  Echo numberTilts: $numberTilts
Endif

# create array of tilt angles
angles = { $startAngle }
Loop 99 i
  angle = $startAngle + $direction * $stepSize * $i
    If ($endAngle > $startAngle AND $angle > $endAngle) OR ($endAngle < $startAngle AND $angle < $endAngle)
     break
    Endif
   angles = { $angles $angle }
EndLoop
   

# start tilt series
Loop $#angles i
   angle = $angles[$i]
   Echo tilt angle: $angle
     
   GoToLowDoseArea R
   SetTargetDefocus $defocus

   TiltTo $angle
   Delay 5

 # set the translation

   If $direction == 1
     IS_Angle = ( $i - 1 ) * 360 * $period / $numberTilts
   ElseIf $direction == -1
     IS_Angle = $i * 360 * $period / $numberTilts
   Endif

   cycles = 47 * $turns
   bgrowth = ($Afinal - $Ainitial ) / $cycles
   IS_Rad = ( $bgrowth * $IS_Angle )
   IS_Rad = $Ainitial + $IS_Rad
   IS_sin = SIN ( $IS_Angle) 
   IS_cos = COS ( $IS_Angle)
   IS_x = $IS_cos * $IS_Rad
   IS_y = $IS_Rad * $IS_sin
   TransR_X = $direction * $IS_x
   TransR_Y = $direction * $IS_y
   shiftX = $isux +$TransR_X
   shiftY = $isuy + $TransR_Y
   ImageShiftByMicrons $shiftX $shiftY

   If $Debug == 1
    Echo cycles = $cycles    Pi * 15
    Echo IS_Angle = $IS_Angle  bgrowth = $bgrowth  
    Echo IS_Rad = $IS_Rad
    Echo IS_Rad = $IS_Rad        
    Echo IS_sin = $IS_sin   IS_cos = $IS_cos   IS_x = $IS_x    IS_y = $IS_y    
    Echo TransR_X = $TransR_X  TransR_Y = $TransR_Y  ImageShiftBy Microns $shiftX $shiftY
   Endif

   CallFunction WaitingToFill
   MultipleRecords
   Save
   ReportImageShift
   Echo current image shift: $repVal1 $repVal2
   SetImageShift $isux $isuy
   Echo reset image shift to: $isux $isuy
   ReportImageShift
   Echo current image shift after reset: $repVal1 $repVal2
EndLoop

TiltTo 0
EndFunction 

#######################
Function WaitingToFill
Delay 2
Loop 15
           AreDewarsFilling
          If $reportedValue1 == 0
                              echo dewars are not filling
                              break
          ElseIf $reportedValue1 == 1
                              echo dewars are filling
                              delay 60 sec
          Endif
      EndLoop
EndFunction
